% start: template for headers and footer info that need to be adde in each pade that includes a section
\chead{\textit{IT-University of Copenhagen} \rangle  SESG-E2013  \rangle \textbf{Group:} 10-Danish Travel card  \rangle \textbf{ID:} Appendix \rangle Responsible: All}
\cfoot{\textbf{Hand-in date:} \today \rangle \textbf{Supervisor:} Marco Nardello \rangle \textbf{Version:} 1 \rangle \textbf{Status: } Done \thepage}
\renewcommand{\headrulewidth}{0.1pt}
\renewcommand{\footrulewidth}{0.1pt}
% ends: headers/footers template

\section*{Waterfall}

\subsection*{Advantages}
Every phase has a defined start and end point.
Progress can be conclusively identified (through the use of milestones) by both vendor and client.

\subsection*{Disadvantages}
If there are many errors in the results, developers need to go back all the processes. 
No user interaction.
Its major problem is the inflexible partitioning
of the project into distinct stages

\subsection*{Characteristic}
The waterfall model is an example of
a plan-driven process—in principle, you must plan and schedule all of the process
activities before starting work on them

In principle, the waterfall model should only be used when the requirements are
well understood and unlikely to change radically during system development.

\section*{Agile}
\subsection*{Advantages}
Saving time for the developing team.
Customer satisfaction by rapid, continuous delivery of useful software.
People and interactions are emphasized rather than process and tools. Customers, developers and testers constantly interact with each other.
Working software is delivered frequently (weeks rather than months).
Close, daily cooperation between business people and developers.
Regular adaptation to changing circumstances.
Even late changes in requirements are welcomed.
Constant Learning, Knowledge Creation and Knowledge Sharing


\subsection*{Disadvantages}
In case of some software deliverables, especially the large ones, it is difficult to assess the effort required at the beginning of the software development life cycle.

There is lack of emphasis on necessary designing and documentation.


\subsection*{Characteristic}
Individuals and interactions over processes and tools. 

Working software over comprehensive documentation.

Customer collaboration over contract negotiation.

Responding to change over following a plan.


\section*{Rational Unified Process (RUP)}

\subsection*{Advantages}
Full of the documents describing for the project. It is good for large project. There are iterations in the different phases. 


\subsection*{Disadvantages}
The team members need to be expert in their field to develop a software under this methodology.

The development process is too complex and disorganized.
It is wasting time to make many documents for a small project.


\subsection*{Characteristic}
RUP provides a full lifecycle approach covering a series of product lifecycle phases called inception, elaboration, construction, and transition.

RUP provides a software development method and a set of software engineering practices that cover the majority of software development disciplines.

RUP is incremental: Each iteration builds on the functionality of the prior iteration; the software application evolves in this fashion with the benefit of regular and continuous feedback.

\section*{Spiral}

\subsection*{Advantages}
Risk management as inbuilt feature.
Changes can be done later without spending much time.

\subsection*{Disadvantages}
High cost involved in this model.
Expertise needed as product has to review and redone time to time.

\subsection*{Characteristic}
The main difference between the spiral model and other software process models is
its explicit recognition of risk. A cycle of the spiral begins by elaborating objectives
such as performance and functionality.

\subsection*{Prototyping}

\subsection*{Advantages}
User is involved throughout the development process, which increases the likelihood of user acceptance of the final implementation.

Small-scale mock-ups of the system are developed following an iterative modification process until the prototype evolves to meet the users’ requirements.

While most prototypes are developed with the expectation that they will be discarded, it is possible in some cases to evolve from prototype to working system.

Since in this methodology a working model of the system is provided, the users get a better understanding of the system being developed.

Errors can be detected much earlier.

Quicker user feedback is available leading to better solutions.

Missing functionality can be identified easily

\subsection*{Disadvantages}

Leads to implementing and then repairing way of building systems.

Practically, this methodology may increase the complexity of the system as scope of the system may expand beyond original plans.

Incomplete application may cause application not to be used as the
full system was designed.

Too much involvement of client, is not always preferred by the developer.

Too many changes can disturb the rhythm of the development team.


\subsection*{Characteristic}
A basic understanding of the fundamental business problem is necessary to avoid solving the wrong problem.

Prototype model should be used when the desired system needs to have a lot of interaction with the end users.


\subsection*{Extreme Programming}

\subsection*{Advantages}
Developers write test code first. It is test driven development. The aim is using test code to design the structures of system. It is good for developers to consider the risks that could be in the structures.

It is fast to develop the software products.

\subsection*{Disadvantages}
XP is more related to the technical people. Business users cannot be part of development.

There are few documents. It is hard to use in the large project.

XP ignore the  software design.

There is no specific process for developing.

\subsection*{Characteristic}
Extreme Programming is an Agile methodology, there are characterized to be an open for adjustments running on development. User words is law, and developers should always have users priority of, which part which must be developed next time, and approval by the fact that it developed was actually what they needed.

\section*{Incremental Development}

\subsection*{Advantages}
- Generates working software quickly and early during the software life cycle.
- More flexible – less costly to change scope and requirements.
- Easier to test and debug during a smaller iteration.
- Customer can respond to each built.
- Lowers initial delivery cost.
- Easier to manage risk because risky pieces are identified and handled during it’d iteration.

\subsection*{Disadvantages}
- Needs good planning and design.
- Needs a clear and complete definition of the whole system before it can be broken down and built incrementally.

\subsection*{Characteristic}
In incremental model the whole requirement is divided into various builds. Multiple development cycles take place here, making the life cycle a “multi-waterfall” cycle.  Cycles are divided up into smaller, more easily managed modules.  Each module passes through the requirements, design, implementation and testing phases.

\section*{Rapid Application Development}

\subsection*{Advantages}
Reduced development time.

Increases reusability of components.

Quick initial reviews occur.

Encourages customer feedback.

\subsection*{Disadvantages}
Depends on strong team and individual performances for identifying business requirements.

Only system that can be modularized can be built using RAD.

High dependency on modeling skills.

There are times when the team ignores necessary quality parameters such as consistency, reliability and standardization.

\subsection*{Characteristic}
RAD should be used when there is a need to create a system that can be modularized in 2-3 months of time.

It should be used if there’s high availability of designers for modeling and the budget is high enough to afford their cost along with the cost of automated code generating tools.
